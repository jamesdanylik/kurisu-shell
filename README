James Danylik
UID 403548957
CS 111, Fall '13


Readme for Kurisu-Shell
=======================
An implmentation of the time-travel-shell for CS111.

Introduction
------------

Implementation Details
----------------------

Usage & Examples
----------------

Raw Project Log & Notes
=======================

* Breakthrough!  While struggling more than anticipated writing that second
  tokenizing function, I had an epiphany while writing a function to bypass 
  comments.  I realized I could successfully bypass the comment in another
  function by simply remembering to return the first byte that wasn't part of
  that comment.  Then I thought; wait, I can do that for basically everything!
  My dynamic buffers will still be useful to hold words, but I don't think
  they'll be any real reason to hold the entire script as a string in a buffer
  somewhere.  This is so much more elegant, I can't resist, even though it will
  involve reworking what I have so far substantionally.  Maybe, and just maybe,
  I can dream of combinging tokens into commands in some way?  Combine the
  second and third functions of my program?  Further work will have to wait
  until tomorrow.
  1009130348

* The first function is complete, and successfully reads the entire script into
  a dynamic buffer in a few neat lines.  I've also developed a type structure 
  for tokens, and believe I will have to implement some form of dynamice array 
  to hold them as well.  Grrr C... but it is kind of zen-like reinventing the
  proverbial wheel.  The second function, reading our nice buffer into the fore-
  described dynamic array of tokens should be fairly easy.  I'm only really
  concerned about the third function, which will have to translate my shiny new
  dynamic array of tokens into some kind of command stream strucutre using the 
  skeleton's predescribed command structure. It's a nice structure and all, but
  it feels like building my house around somebody's kitchen; confusing.  Anyway,
  this thrid function will have to use two stacks, and will be much like the 
  excellent example given in section, so I know where to begin there.  Work
  continues.
  1009130023 

* Work continues on developing a working context free grammar to describe our
  shell langauge.  The two entry points referenced in main.c and described in 
  read-command.h suggests a lexer/parser arrangement, but at the same time the
  way the project skeleton outputs the tree suggests that make_command_stream
  should already have knowledge of the proper indentation levels before
  read_command_stream is ever callled; i.e. it must have knowledge of the 
  overall command structure in order to do so and therefore need to have
  completely processed the input by that point.

  Resultingly, my strategy for the time being will be to read in the input
  script in its' entirity ito a buffer when make_command_stream is called.  I
  will then build a function to turn this buffered stream of characters into a 
  series of terminal tokens.  A second function will take this series of tokens
  and attempt to process them via the described grammer into the partially
  descibed command structure, and simply store this finished structure to feed
  to read command.
  1008132042

* The skeleton fails to build by default, due to strict warnings and unused
  parameters.  Readding void declarations in front of the unused the variables
  in order to avoid changing the build process, as I want the strict checks!
  Added voids to read-command.c and execute-command.c, and everything builds
  as expected.
  1008131520

* After a nasty incident involving a wayward 'git rm -rf', I'm back up and
  running.  Getting the git repo up first this time... doh!
  1008131514

Notes on Tokens
---------------

* Words      | 1 or more of the following characters:
             | a-z A-z 0-9 ! % + , - . / : @ ^ _

* Special    | |  | Pipe
  Tokens     | && | And
             | || | Or
             | () | Subshells
             | <> | Redirects

Descriptions for the shell syntax:
----------------------------------

* Simple Command - Sequences of one or more words.  The first is the word to be
                   executed.

* Subshells      - Complete commands surrounded by ( ).

* Redirections   - Simple commands with I/O redirections.  An I/O redirect is
                   possibly empty, or one of the following:
                       * < WORD
                       * > WORD
                       * < WORD > WORD

* Piplines       - One or more commands seperated by |.

* And/Or's       - One or more piplines seperated by && or ||.  The && and ||
                   operators are defined to have the same precedence.

* Complete       - Which are one or more and-ors each seperated by a semicolon
  Commands         or newline, and which are optionally followed by a semicolon.
                   An entire shell script is a complete command.

* Comments       - Each consisting of a # that is not immediately preceded by an
                   ordinary token, followed by characteres up to (but not
                   including) the next NEWLINE.

* Whitespace     - Consisting of SPACE, TAB, and NEWLINE.  NEWLINE is special:
                   as described above, it can substitute for SEMICOLON.  Also,
                   although WHITEPSACE can ordinarily appear before and after 
                   any token, the only tokens that newlines can appear before
                   are ( ), and the first words fo simple commands.  NEWLINES
                   may follow any special token other than < and >.

Errors
------

If the script given does not fall within the above language, the implmentation
should output the line number and a colon, followed by some reasonable message.


